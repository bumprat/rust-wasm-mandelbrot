<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <style>
      body {
        margin: 0px;
        background-color: #444;
        overflow: hidden;
        font-size: 0.5em;
      }
      #toolbox {
        position: absolute;
        top: 0;
        left: 0;
        background-color: #444;
        color: white;
        padding: 10px;
        opacity: 0.5;
        width: 100px;
      }
      #toolbox input {
        width: 80%;
      }
      #stage_info {
        background-color: grey;
        padding: 5px;
        font-size: 0.2em;
      }
      #console {
        overflow-wrap: break-word;
        background-color: black;
        padding: 5px;
        font-size: 0.2em;
      }
      #favorites {
        margin-top: 10px;
        margin-bottom: 10px;
      }
    </style>
    <title>Mandelbrot Set</title>
  </head>
  <body>
    <canvas id="stage" width="400" , height="400" style="touch-action: none">
    </canvas>
    <canvas id="supersample" style="display: none"> </canvas>
    <div id="toolbox">
      <div>
        iteration:
        <input id="max_iter" type="number" />
      </div>
      <div>
        oversample:
        <input id="super_sample" type="number" />
      </div>
      <div>
        color:
        <div style="padding-left: 1em">
          <div>
            step:
            <input id="color_step" type="number" />
          </div>
          <div>
            number:
            <input id="color_number" type="number" />
          </div>
          <div>
            shift:
            <input id="color_shift" type="number" />
          </div>
        </div>
      </div>
      <div id="favorites">
        <button id="favorite-add">add</button>
        <button id="favorite-reset">reset</button>
      </div>
      <div id="stage_info"></div>
      <div id="console"></div>
    </div>
    <script type="module">
      import init, { paint, transfer } from "./pkg/rust_wasm_mandelbrot.js";
      const consolediv = document.querySelector("#console");

      const throttle = (fn, delay) => {
        let lastCalled = 0;
        return (...args) => {
          let now = new Date().getTime();
          if (now - lastCalled < delay) {
            return;
          }
          lastCalled = now;
          return fn(...args);
        };
      };

      const debounce = function (fn, timeout = 300) {
        let timer;
        return (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => {
            fn.apply(this, args);
          }, timeout);
        };
      };

      let favoriteAddBtn = document.querySelector("#favorite-add");
      let favoriteResetBtn = document.querySelector("#favorite-reset");
      let canvas = document.querySelector("#stage");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      let stage = {
        centerx: 0,
        centery: 0,
        scale: Math.min(canvas.width, canvas.height) / 4,
        superSampleFactor: 1,
        color_step: 5,
        color_number: 24,
        color_shift: 16,
      };

      const superSample = document.querySelector("#super_sample");
      superSample.value = stage.superSampleFactor;
      superSample.onchange = () => {
        stage.superSampleFactor = parseInt(superSample.value);
        render(document.querySelector("#stage"));
      };

      const maxIter = document.querySelector("#max_iter");
      let max_iter = 100;
      maxIter.value = max_iter;
      maxIter.onchange = () => {
        max_iter = parseInt(maxIter.value);
        render(document.querySelector("#stage"));
      };

      const color_step = document.querySelector("#color_step");
      const color_number = document.querySelector("#color_number");
      const color_shift = document.querySelector("#color_shift");
      color_step.value = stage.color_step;
      color_step.onchange = () => {
        stage.color_step = parseInt(color_step.value);
        render(document.querySelector("#stage"));
      };
      color_number.value = stage.color_number;
      color_number.onchange = () => {
        stage.color_number = parseInt(color_number.value);
        render(document.querySelector("#stage"));
      };
      color_shift.value = stage.color_shift;
      color_shift.onchange = () => {
        stage.color_shift = parseInt(color_shift.value);
        render(document.querySelector("#stage"));
      };
      const stageInfo = document.querySelector("#stage_info");
      function render(canvas) {
        const start = performance.now();
        paint(
          max_iter,
          stage.centerx,
          stage.centery,
          stage.scale,
          stage.superSampleFactor,
          stage.color_step,
          stage.color_number,
          stage.color_shift
        );
        document.querySelector("#console").innerHTML = JSON.stringify(stage);
        const end = performance.now();
        const renderTime = end - start;
        transfer(0, 0, canvas.width, canvas.height);
        let centerx = stage.centerx.toExponential(2);
        let centery = stage.centery.toExponential(2);
        stageInfo.innerHTML = `center: (${centerx}, ${centery})<br/>`;
        stageInfo.innerHTML += `scale: ${stage.scale.toFixed(0)}<br/>`;
        stageInfo.innerHTML += `render time: ${renderTime.toFixed(0)}ms`;
      }

      function enable_pan_zoom(canvas) {
        let basePoint = [0, 0];
        let evCache = [];
        let baseDistance = 0;
        let zoomFactor = 1;
        function start(ev) {
          let prev_avg_x =
            evCache.length == 0
              ? 0
              : evCache.map((e) => e.clientX).reduce((v, s) => v + s, 0) /
                evCache.length;
          let prev_avg_y =
            evCache.length == 0
              ? 0
              : evCache.map((e) => e.clientY).reduce((v, s) => v + s, 0) /
                evCache.length;
          basePoint = [
            basePoint[0] +
              (ev.clientX - prev_avg_x) / (evCache.length + 1) / zoomFactor,
            basePoint[1] +
              (ev.clientY - prev_avg_y) / (evCache.length + 1) / zoomFactor,
          ];
          evCache.push(ev);

          let min_x = Math.min(...evCache.map((e) => e.clientX));
          let min_y = Math.min(...evCache.map((e) => e.clientY));
          let max_x = Math.max(...evCache.map((e) => e.clientX));
          let max_y = Math.max(...evCache.map((e) => e.clientY));
          baseDistance =
            Math.sqrt(
              (max_y - min_y) * (max_y - min_y) +
                (max_x - min_x) * (max_x - min_x)
            ) / zoomFactor;
        }
        function move(ev) {
          if (evCache.length === 0) return;
          const index = evCache.findIndex(
            (cachedEv) => cachedEv.pointerId === ev.pointerId
          );
          index >= 0 && evCache.splice(index, 1, ev);
          let avg_x =
            evCache.map((e) => e.clientX).reduce((v, s) => v + s, 0) /
            evCache.length;
          let avg_y =
            evCache.map((e) => e.clientY).reduce((v, s) => v + s, 0) /
            evCache.length;
          let min_x = Math.min(...evCache.map((e) => e.clientX));
          let min_y = Math.min(...evCache.map((e) => e.clientY));
          let max_x = Math.max(...evCache.map((e) => e.clientX));
          let max_y = Math.max(...evCache.map((e) => e.clientY));
          let distance = Math.sqrt(
            (max_y - min_y) * (max_y - min_y) +
              (max_x - min_x) * (max_x - min_x)
          );
          zoomFactor = distance === 0 ? zoomFactor : distance / baseDistance;
          let deltaMovement = [avg_x - basePoint[0], avg_y - basePoint[1]];
          transfer(
            deltaMovement[0] + basePoint[0] * (1 - zoomFactor),
            deltaMovement[1] + basePoint[1] * (1 - zoomFactor),
            canvas.width * zoomFactor,
            canvas.height * zoomFactor
          );
        }
        function end(ev) {
          if (evCache.length === 0) return;
          const index = evCache.findIndex(
            (cachedEv) => cachedEv.pointerId === ev.pointerId
          );
          if (index >= 0) {
            // end can be fired multiple times when pointerleave
            if (evCache.length > 1) {
              let prev_avg_x =
                evCache.map((e) => e.clientX).reduce((v, s) => v + s) /
                evCache.length;
              let prev_avg_y =
                evCache.map((e) => e.clientY).reduce((v, s) => v + s) /
                evCache.length;
              basePoint = [
                basePoint[0] +
                  (prev_avg_x - ev.clientX) / (evCache.length - 1) / zoomFactor,
                basePoint[1] +
                  (prev_avg_y - ev.clientY) / (evCache.length - 1) / zoomFactor,
              ];
            } else if (evCache.length == 1) {
              let deltaMovement = [
                ev.clientX - basePoint[0],
                ev.clientY - basePoint[1],
              ];
              basePoint = [0, 0];
              stage.centerx =
                stage.centerx +
                (((ev.clientX - canvas.width / 2) * (zoomFactor - 1)) /
                  zoomFactor -
                  deltaMovement[0]) /
                  stage.scale;
              stage.centery =
                stage.centery -
                (((ev.clientY - canvas.height / 2) * (zoomFactor - 1)) /
                  zoomFactor -
                  deltaMovement[1]) /
                  stage.scale;
              stage.scale *= zoomFactor;
              render(canvas);
              zoomFactor = 1;
            }
            evCache.splice(index, 1);
            let min_x = Math.min(...evCache.map((e) => e.clientX));
            let min_y = Math.min(...evCache.map((e) => e.clientY));
            let max_x = Math.max(...evCache.map((e) => e.clientX));
            let max_y = Math.max(...evCache.map((e) => e.clientY));
            let distance = Math.sqrt(
              (max_y - min_y) * (max_y - min_y) +
                (max_x - min_x) * (max_x - min_x)
            );
            baseDistance = distance / zoomFactor;
          }
        }

        let topLeftPoint = [0, 0];
        let scrollZoomFactor = 1;
        let wheelZoomRender = debounce(() => {
          stage.scale *= scrollZoomFactor;
          stage.centerx -=
            (((scrollZoomFactor - 1) * canvas.width) / 2 + topLeftPoint[0]) /
            stage.scale;
          stage.centery +=
            (((scrollZoomFactor - 1) * canvas.height) / 2 + topLeftPoint[1]) /
            stage.scale;
          render(canvas);
          topLeftPoint = [0, 0];
          scrollZoomFactor = 1;
        });
        function wheel(ev) {
          let zoomFactor = ev.deltaY < 0 ? 1.2 : 0.9;
          scrollZoomFactor *= zoomFactor;
          topLeftPoint = [
            ev.clientX - zoomFactor * (ev.clientX - topLeftPoint[0]),
            ev.clientY - zoomFactor * (ev.clientY - topLeftPoint[1]),
          ];
          transfer(
            topLeftPoint[0],
            topLeftPoint[1],
            canvas.width * scrollZoomFactor,
            canvas.height * scrollZoomFactor
          );
          wheelZoomRender();
        }

        canvas.onpointerdown = start;
        canvas.onpointermove = move;
        canvas.onpointerup = end;
        canvas.onpointercancel = end;
        canvas.onpointerout = end;
        canvas.onpointerleave = end;
        canvas.onwheel = wheel;
      }
      async function run() {
        await init();
        let canvas = document.querySelector("#stage");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        render(canvas);
        enable_pan_zoom(canvas);
      }
      run();
    </script>
  </body>
</html>
